## following 메뉴에 debouncing을 적용하지 않은 이유

1. 코드가 복잡해진다.

2. 처리를 하는 과정에서 자원이 많이 사용되면 이득이 크겠지만, 그렇지 않다.

## 로그인/회원가입을 할 때 submit 대신 click으로

동일한 input 이메일과 비밀번호로 로그인과 회원가입을 동시에 처리하고 싶었다.

그런데 submit으로는 로그인을 눌렀는지 회원가입을 눌렀는지 판단할 수가 없음

## 인증에서 리덕스를 사용한 이유

currentUser로 사용하면 정보를 가져오는데 시간이 걸린다.

context api를 사용하려니 여러 문제가 생긴다.

1. 다른 reducer(또는 context)가 들어오면 태그 네스팅이 일어난다.

2. 해당 setState나 dispatch(useReducer를 사용한 경우)가 있는 컴포넌트부터 전체가 다 렌더링이 된다. 해당 앱의 경우 \_app에서 이를 사용할 것인데, header만 다시 렌더링이 되면 되는데 본문이나 footer도 다시 렌더링이 된다.

## 댓글을 realtime에서 firestore로 바꾼 이유

댓글 삭제 버튼을 누르는데 갑자기 realtime이 반영이 되어서 잘못 누르게 되는 수도 있어서

realtime에서 새로 고침을 하지 않으면 작성자가 다른 사람이 됨 -> 해결하지 못함

## header의 category 및 auth의 웹 접근성

처음에는 그냥 hover만 하면 밑에 목록이 열리도록 하였음

근데 그렇게 하려니 tab으로 해당 항목들이 열리지 않음

그래서 고민을 하던 중 css hover를 쓰면 안 되고 mouseenter와 mouseleave를 써야 함을 알았음

그리고 그 과정에서 mouseover, mouseout와 mouseenter, mouseleave의 차이점을 알게 됨

## article을 수정하거나 삭제할 때 search에 반영해야 하나?

과정을 보면 다음과 같다.

getDoc을 통해 배열을 가져와서 일일이 해당 아이디와 맞는 것을 체크한 후 updateDoc을 해야 한다.

updateDoc은 await을 할 필요가 없다. 하지만 getDoc과 배열에서 체크하는 것은 반드시 그 자리에서 해야 한다.

만약 getDoc을 안 하고 redux에서 가져오는 경우도 문제다. 왜냐하면 다른 유저가 글을 올렸을 수 있기 때문이다. 다른 유저가 글을 올린 상태에서 해당 유저가 redux에서 가져온 것을 반영해서 올리면 다른 유저가 올린 글이 삭제된다.

onSnapshot을 쓸 수도 있겠지만 그렇게 되면 부담이 커진다.

1. 배열이 아니라 key value로 하면 순환할 필요가 없지 않나?

개수가 많아서 옛날 거를 삭제하려고 하면 못 한다. 왜냐하면 순서가 없기 때문에

2. 이미 오래된 글이어서 search에 없을 수 있다.

이러면 헛수고가 된다.

3. 새로운 글들이 올라오면 자연스럽게 삭제된다.
